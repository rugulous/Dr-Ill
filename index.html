<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Doctor Ill</title>
		<style>
			html,
			body {
				margin: 0;
				padding: 0;
				height: 100%;
			}

			body {
				overflow: hidden;
				background-color: #0F0;
				display: flex;
				justify-content: center;
				align-items: center;
			}
		</style>
	</head>

	<body>
		<canvas id="canvas"></canvas>
	</body>

	<script src="Canvas.js"></script>

	<script>
		const FIELD_WIDTH = 160;
		const FIELD_HEIGHT = 90.6;
		const PIT_BOX = 5.33333;
		const STEPS_PER_MARKER = 8;
		const FRONT_HASH = 32 + PIT_BOX;
		const BACK_HASH = 53.33333 + PIT_BOX;

		const canvas = new Canvas("canvas", FIELD_WIDTH, FIELD_HEIGHT);
		let performer = null;
		let currentSet = 0;

		function resize() {
			scale = getScale();
			canvas.setScale(scale);
			draw();
		}

		function draw() {
			drawField();

			if (performer != null) {
				let setIndex = currentSet;
				if (performer.sets[currentSet].isSubset) {
					while (true) {
						setIndex--;
						if (!performer.sets[setIndex].isSubset) {
							break;
						}
					}
				}

				drawSet(setIndex);
			}

		}

		function drawSet(set) {
			canvas.drawText(`Set ${performer.sets[currentSet].identifier}`, 1, 5, {font: `${scale * 2}px Asket`, alignment: "left"});

			if (performer.sets[currentSet].isSubset) {
				canvas.drawText(`(Subset, so drawing set ${performer.sets[set].identifier})`, 1, 10);
			}

			canvas.drawText(performer.symbol, performer.sets[set].x + (FIELD_WIDTH / 2), FIELD_HEIGHT - (PIT_BOX + performer.sets[set].y), {alignment: "center"});
		}

		function drawField() {
			canvas.drawRect(0, 0, FIELD_WIDTH, FIELD_HEIGHT, "#008000");
			canvas.drawRect(0, FIELD_HEIGHT - PIT_BOX, FIELD_WIDTH, PIT_BOX, "#006400");
			canvas.drawRect(0, FIELD_HEIGHT - PIT_BOX, FIELD_WIDTH, 1 / scale, "#FFF");

			for (let i = 0; i <= 20; i++) {
				canvas.drawRect(i * STEPS_PER_MARKER, 0, (i == 10 ? 0.3333 : 0.1), FIELD_HEIGHT - PIT_BOX);

				const yardLine = (i * STEPS_PER_MARKER) - 2;

				canvas.drawRect(yardLine, FIELD_HEIGHT - FRONT_HASH, 4, 0.1);
				canvas.drawRect(yardLine, FIELD_HEIGHT - BACK_HASH, 4, 0.1);

				for (let j = 1; j < STEPS_PER_MARKER; j++) {
					canvas.drawRect((i * STEPS_PER_MARKER) + j, FIELD_HEIGHT - PIT_BOX - 1, 0.1, 1);
				}
			}

			for (let i = 0; i < 7; i++) {
				canvas.drawCircle(FIELD_WIDTH / 2, FIELD_HEIGHT - (PIT_BOX + (i * STEPS_PER_MARKER)), 0.33333);
			}
		}

		function getScale() {
			const w = Math.floor(window.innerHeight / FIELD_HEIGHT);
			const h = Math.floor(window.innerWidth / FIELD_WIDTH);
			return Math.min(w, h);
		}

		function processDrill(text) {
			const drill = text.replaceAll("\r", "").split("\n");
			performer = {
				name: drill[0],
				symbol: drill[1],
				sets: []
			};

			for (let i = 2; i < drill.length - 1; i += 3) {
				const set = {
					identifier: drill[i],
					counts: drill[i + 1],
					isSubset: drill[i + 2] == "-"
				};

				if (!set.isSubset) {
					const coords = drill[i + 2].split(",");
					set.x = parseFloat(coords[0]) * -1;
					set.y = parseFloat(coords[1]);
				}

				performer.sets.push(set);
			}

			draw();
		}

		window.addEventListener("resize", resize);
		window.addEventListener("keydown", ev => {
			if (ev.key == "ArrowLeft" && currentSet > 0) {
				currentSet--;
			} else if (ev.key == "ArrowRight" && currentSet < performer?.sets.length - 1) {
				currentSet++;
			} else {
				return;
			}

			draw();
		});

		resize();

		fetch("sample.drill").then(res => res.text()).then(processDrill);
	</script>

</html>