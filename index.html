<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Doctor Ill</title>
		<style>
			html,
			body {
				margin: 0;
				padding: 0;
				height: 100%;
			}

			body {
				overflow: hidden;
				background-color: #0F0;
				display: flex;
				justify-content: center;
				align-items: center;
			}
		</style>
	</head>

	<body>
		<canvas id="canvas"></canvas>
	</body>

	<script src="Canvas.js"></script>

	<script>
		let NUM_MARKERS = 14;
		const STEPS_PER_MARKER = 8;
		let FIELD_WIDTH = NUM_MARKERS * STEPS_PER_MARKER;
		let FIELD_HEIGHT = 60.6;
		const PIT_BOX = 5.33333;
		const FRONT_HASH = 32 + PIT_BOX;
		const BACK_HASH = 53.33333 + PIT_BOX;
		const font = "sans-serif";

		const canvas = new Canvas("canvas", FIELD_WIDTH, FIELD_HEIGHT);
		let currentSet = 0;
		let showGrid = JSON.parse(localStorage.getItem("showGrid"));
		let setXOffset = 0;

		const show = {
			name: "",
			bpm: 0,
			sets: [],
			performers: []
		};


		function resize() {
			scale = getScale();
			canvas.setScale(scale);
			draw();
		}

		function draw() {
			drawField();

			drawShow();
			drawSet(currentSet);
		}

		function drawShow() {
			let startX = setXOffset;
			canvas.setTextAlign("center");
			canvas.setFont(`${scale * 1.5}px ${font}`);
			show.sets.forEach((set, i) => {
				const width = (i == show.sets.length - 1) ? FIELD_WIDTH : set.counts;

				canvas.drawRect(startX, 0, width, 3, (startX == 0 ? "#FFF" : "rgba(255, 255, 255, 0.6)"));
				canvas.strokeRect(startX, 0, width, 3, "#000");
				canvas.drawText(set.identifier, startX + (width / 2), 1.5);
				startX += set.counts;
			});

			canvas.setFill("#FFF");
		}

		function drawSet(set) {
			canvas.setFill("#F00");
			canvas.setFont(`bold ${scale * 1.5}px ${font}`);

			show.performers.forEach(p => {
				if (p.dots.length < set) {
					return;
				}

				canvas.drawText(p.symbol, p.dots[set].x + (FIELD_WIDTH / 2), FIELD_HEIGHT - (PIT_BOX + p.dots[set].y), { alignment: "center" });
			});

		}

		function drawField() {
			canvas.drawRect(0, 0, FIELD_WIDTH, FIELD_HEIGHT, "#008000");
			canvas.drawRect(0, FIELD_HEIGHT - PIT_BOX, FIELD_WIDTH, PIT_BOX, "#006400");
			canvas.drawRect(0, FIELD_HEIGHT - PIT_BOX, FIELD_WIDTH, 1 / scale, "#FFF");

			if (showGrid) {
				canvas.setFill("rgba(200, 200, 200, 0.3)");
				for (let x = 0; x < FIELD_WIDTH; x++) {
					canvas.drawRect(x, 0, 0.1, FIELD_HEIGHT - PIT_BOX);
				}

				for (let y = FIELD_HEIGHT - PIT_BOX; y > 0; y--) {
					if (Math.floor(y - 1) % 4 == 0) {
						canvas.setFill("rgba(200, 200, 200, 0.6)");
					}

					canvas.drawRect(0, y, FIELD_WIDTH, 0.1);

					if (Math.floor(y - 1) % 4 == 0) {
						canvas.setFill("rgba(200, 200, 200, 0.3)");
					}
				}

				canvas.setFill("#FFF");
			}

			for (let i = 0; i <= NUM_MARKERS; i++) {
				canvas.drawRect(i * STEPS_PER_MARKER, 0, (i == NUM_MARKERS / 2 ? 0.3333 : 0.1), FIELD_HEIGHT - PIT_BOX);

				const yardLine = (i * STEPS_PER_MARKER) - 2;

				canvas.drawRect(yardLine, FIELD_HEIGHT - FRONT_HASH, 4, 0.1);
				canvas.drawRect(yardLine, FIELD_HEIGHT - BACK_HASH, 4, 0.1);

				for (let j = 1; j < STEPS_PER_MARKER; j++) {
					canvas.drawRect((i * STEPS_PER_MARKER) + j, FIELD_HEIGHT - PIT_BOX - 1, 0.1, 1);
				}
			}

			for (let i = 0; i < 7; i++) {
				canvas.drawCircle(FIELD_WIDTH / 2, FIELD_HEIGHT - (PIT_BOX + (i * STEPS_PER_MARKER)), 0.33333);
			}
		}

		function getScale() {
			const w = Math.floor(window.innerHeight / FIELD_HEIGHT);
			const h = Math.floor(window.innerWidth / FIELD_WIDTH);
			return Math.min(w, h);
		}

		window.addEventListener("resize", resize);
		window.addEventListener("keydown", ev => {
			if (ev.key == "ArrowLeft" && currentSet > 0) {
				currentSet--;
				setXOffset += show.sets[currentSet].counts;
			} else if (ev.key == "ArrowRight" && currentSet < show.sets.length - 1) {
				setXOffset -= show.sets[currentSet].counts;
				currentSet++;
			} else if (ev.key == "g") {
				showGrid = !showGrid;
				localStorage.setItem("showGrid", showGrid);
			} else {
				return;
			}

			draw();
		});

		resize();

		fetch("all.drill").then(res => res.text()).then(processAllDrill);

		function processAllDrill(text) {
			let maxX = 0, maxY = 0;

			const lines = text.split("\r\n");
			show.name = lines[0];
			show.bpm = parseInt(lines[1]);

			let i;
			for (i = 2; i < lines.length; i += 2) {
				if (lines[i] == "-----") {
					break;
				}

				show.sets.push({
					identifier: lines[i],
					counts: parseInt(lines[i + 1])
				});
			}

			let performer = null;
			while (i < lines.length - 2) {
				if (lines[i] == "-----") {
					if (performer != null) {
						show.performers.push(performer);
					}

					performer = {
						name: lines[i + 1],
						symbol: lines[i + 2],
						dots: []
					};

					i += 3;
					continue;
				}

				const coords = lines[i].split(",");
				let dot = {
					x: parseFloat(coords[0]) * -1,
					y: parseFloat(coords[1])
				};

				
				if (isNaN(dot.x) || isNaN(dot.y)) {
					dot = performer.dots[performer.dots.length - 1];
				}

				if(Math.abs(dot.x) > maxX){
					maxX = Math.abs(dot.x);
				}

				if(dot.y > maxY){
					maxY = dot.y;
				}
				
				performer.dots.push(dot);
				i++;
			}

			//yum - maybe these shouldn't be CONSTANT_CASE
			NUM_MARKERS = Math.ceil(maxX / STEPS_PER_MARKER) * 2;
			FIELD_WIDTH = NUM_MARKERS * STEPS_PER_MARKER;
			FIELD_HEIGHT = maxY + 4 + PIT_BOX;

			canvas.resize(FIELD_WIDTH, FIELD_HEIGHT);

			draw();
		}
	</script>

</html>